export interface RayHit {
  distance: number;
  side: number;
  wallType: number;
  x: number;
  y: number;
}

export class RenderingSystem {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private canvasWidth = 800;
  private canvasHeight = 600;
  private readonly FOV = Math.PI / 3;
  private numRays = 400; // Make this dynamic instead of readonly

  // Offscreen canvas for optimization
  private offscreenCanvas: HTMLCanvasElement;
  private offscreenCtx: CanvasRenderingContext2D;

  // Enemy texture definitions - 16x16 pixel arrays
  private readonly ENEMY_TEXTURES = {
    grunt: {
      idle: [
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#8B4",
          "#8B4",
          "#333",
          "#333",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#333",
          "#333",
          "#8B4",
          "#8B4",
          "#000",
        ],
        [
          "#000",
          "#8B4",
          "#333",
          "#00F",
          "#00F",
          "#333",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#333",
          "#00F",
          "#00F",
          "#333",
          "#8B4",
          "#000",
        ],
        [
          "#000",
          "#8B4",
          "#333",
          "#FFF",
          "#FFF",
          "#333",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#333",
          "#FFF",
          "#FFF",
          "#333",
          "#8B4",
          "#000",
        ],
        [
          "#000",
          "#8B4",
          "#8B4",
          "#000",
          "#000",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#000",
          "#000",
          "#8B4",
          "#8B4",
          "#000",
        ],
        [
          "#000",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#000",
        ],
        [
          "#000",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#654",
          "#654",
          "#654",
          "#654",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#8B4",
          "#000",
        ],
        [
          "#000",
          "#8B4",
          "#8B4",
          "#8B4",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#8B4",
          "#8B4",
          "#8B4",
          "#000",
        ],
        [
          "#000",
          "#8B4",
          "#8B4",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#8B4",
          "#8B4",
          "#000",
        ],
        [
          "#000",
          "#8B4",
          "#654",
          "#654",
          "#654",
          "#321",
          "#654",
          "#654",
          "#654",
          "#654",
          "#321",
          "#654",
          "#654",
          "#654",
          "#8B4",
          "#000",
        ],
        [
          "#000",
          "#654",
          "#654",
          "#654",
          "#321",
          "#321",
          "#321",
          "#654",
          "#654",
          "#321",
          "#321",
          "#321",
          "#654",
          "#654",
          "#654",
          "#000",
        ],
        [
          "#000",
          "#654",
          "#654",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#654",
          "#654",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
      ],
      attacking: [
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#A64",
          "#A64",
          "#333",
          "#333",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#333",
          "#333",
          "#A64",
          "#A64",
          "#000",
        ],
        [
          "#000",
          "#A64",
          "#333",
          "#FF0",
          "#FF0",
          "#333",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#333",
          "#FF0",
          "#FF0",
          "#333",
          "#A64",
          "#000",
        ],
        [
          "#000",
          "#A64",
          "#333",
          "#FFF",
          "#FFF",
          "#333",
          "#A64",
          "#A64",
          "#A64",
          "#A64",
          "#333",
          "#FFF",
          "#FFF",
          "#333",
          "#A64",
          "#000",
        ],
        [
          "#000",
          "#A64",
          "#A64",
          "#333",
          "#333",
          "#A64",
          "#A64",
          "#000",
          "#000",
          "#A64",
          "#A64",
          "#333",
          "#333",
          "#A64",
          "#A64",
          "#000",
        ],
        [
          "#000",
          "#A64",
          "#A64",
          "#000",
          "#000",
          "#000",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#000",
          "#000",
          "#000",
          "#A64",
          "#A64",
          "#000",
        ],
        [
          "#000",
          "#A64",
          "#A64",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#A64",
          "#A64",
          "#000",
        ],
        [
          "#000",
          "#A64",
          "#A64",
          "#A64",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#A64",
          "#A64",
          "#A64",
          "#000",
        ],
        [
          "#000",
          "#A64",
          "#A64",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#654",
          "#A64",
          "#A64",
          "#000",
        ],
        [
          "#000",
          "#A64",
          "#654",
          "#654",
          "#654",
          "#321",
          "#654",
          "#654",
          "#654",
          "#654",
          "#321",
          "#654",
          "#654",
          "#654",
          "#A64",
          "#000",
        ],
        [
          "#000",
          "#654",
          "#654",
          "#654",
          "#321",
          "#321",
          "#321",
          "#654",
          "#654",
          "#321",
          "#321",
          "#321",
          "#654",
          "#654",
          "#654",
          "#000",
        ],
        [
          "#000",
          "#654",
          "#654",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#654",
          "#654",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#321",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
      ],
    },
    soldier: {
      idle: [
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#556",
          "#556",
          "#222",
          "#222",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#222",
          "#222",
          "#556",
          "#556",
          "#000",
        ],
        [
          "#000",
          "#556",
          "#222",
          "#0F0",
          "#0F0",
          "#222",
          "#556",
          "#556",
          "#556",
          "#556",
          "#222",
          "#0F0",
          "#0F0",
          "#222",
          "#556",
          "#000",
        ],
        [
          "#000",
          "#556",
          "#222",
          "#FFF",
          "#FFF",
          "#222",
          "#556",
          "#556",
          "#556",
          "#556",
          "#222",
          "#FFF",
          "#FFF",
          "#222",
          "#556",
          "#000",
        ],
        [
          "#000",
          "#556",
          "#556",
          "#000",
          "#000",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#000",
          "#000",
          "#556",
          "#556",
          "#000",
        ],
        [
          "#000",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#556",
          "#000",
        ],
        [
          "#000",
          "#556",
          "#556",
          "#334",
          "#334",
          "#556",
          "#334",
          "#334",
          "#334",
          "#334",
          "#556",
          "#334",
          "#334",
          "#556",
          "#556",
          "#000",
        ],
        [
          "#000",
          "#556",
          "#556",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#556",
          "#556",
          "#000",
        ],
        [
          "#000",
          "#556",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#556",
          "#000",
        ],
        [
          "#000",
          "#334",
          "#334",
          "#334",
          "#334",
          "#223",
          "#334",
          "#334",
          "#334",
          "#334",
          "#223",
          "#334",
          "#334",
          "#334",
          "#334",
          "#000",
        ],
        [
          "#000",
          "#334",
          "#334",
          "#334",
          "#223",
          "#223",
          "#223",
          "#334",
          "#334",
          "#223",
          "#223",
          "#223",
          "#334",
          "#334",
          "#334",
          "#000",
        ],
        [
          "#000",
          "#223",
          "#334",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#334",
          "#223",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
      ],
      attacking: [
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#667",
          "#667",
          "#222",
          "#222",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#667",
          "#222",
          "#222",
          "#667",
          "#667",
          "#000",
        ],
        [
          "#000",
          "#667",
          "#222",
          "#F80",
          "#F80",
          "#222",
          "#667",
          "#667",
          "#667",
          "#667",
          "#222",
          "#F80",
          "#F80",
          "#222",
          "#667",
          "#000",
        ],
        [
          "#000",
          "#667",
          "#222",
          "#FFF",
          "#FFF",
          "#222",
          "#667",
          "#667",
          "#667",
          "#667",
          "#222",
          "#FFF",
          "#FFF",
          "#222",
          "#667",
          "#000",
        ],
        [
          "#000",
          "#667",
          "#667",
          "#333",
          "#333",
          "#667",
          "#667",
          "#000",
          "#000",
          "#667",
          "#667",
          "#333",
          "#333",
          "#667",
          "#667",
          "#000",
        ],
        [
          "#000",
          "#667",
          "#667",
          "#000",
          "#000",
          "#000",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#000",
          "#000",
          "#000",
          "#667",
          "#667",
          "#000",
        ],
        [
          "#000",
          "#667",
          "#667",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#667",
          "#667",
          "#000",
        ],
        [
          "#000",
          "#667",
          "#667",
          "#334",
          "#334",
          "#667",
          "#334",
          "#334",
          "#334",
          "#334",
          "#667",
          "#334",
          "#334",
          "#667",
          "#667",
          "#000",
        ],
        [
          "#000",
          "#667",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#334",
          "#667",
          "#000",
        ],
        [
          "#000",
          "#334",
          "#334",
          "#334",
          "#334",
          "#223",
          "#334",
          "#334",
          "#334",
          "#334",
          "#223",
          "#334",
          "#334",
          "#334",
          "#334",
          "#000",
        ],
        [
          "#000",
          "#334",
          "#334",
          "#334",
          "#223",
          "#223",
          "#223",
          "#334",
          "#334",
          "#223",
          "#223",
          "#223",
          "#334",
          "#334",
          "#334",
          "#000",
        ],
        [
          "#000",
          "#223",
          "#334",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#334",
          "#223",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#223",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
      ],
    },
    captain: {
      idle: [
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#408",
          "#408",
          "#111",
          "#111",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#111",
          "#111",
          "#408",
          "#408",
          "#000",
        ],
        [
          "#000",
          "#408",
          "#111",
          "#F0F",
          "#F0F",
          "#111",
          "#408",
          "#408",
          "#408",
          "#408",
          "#111",
          "#F0F",
          "#F0F",
          "#111",
          "#408",
          "#000",
        ],
        [
          "#000",
          "#408",
          "#111",
          "#FFF",
          "#FFF",
          "#111",
          "#408",
          "#408",
          "#408",
          "#408",
          "#111",
          "#FFF",
          "#FFF",
          "#111",
          "#408",
          "#000",
        ],
        [
          "#000",
          "#408",
          "#408",
          "#000",
          "#000",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#000",
          "#000",
          "#408",
          "#408",
          "#000",
        ],
        [
          "#000",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#408",
          "#000",
        ],
        [
          "#000",
          "#408",
          "#408",
          "#306",
          "#306",
          "#408",
          "#306",
          "#306",
          "#306",
          "#306",
          "#408",
          "#306",
          "#306",
          "#408",
          "#408",
          "#000",
        ],
        [
          "#000",
          "#408",
          "#408",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#408",
          "#408",
          "#000",
        ],
        [
          "#000",
          "#408",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#408",
          "#000",
        ],
        [
          "#000",
          "#306",
          "#306",
          "#306",
          "#306",
          "#204",
          "#306",
          "#306",
          "#306",
          "#306",
          "#204",
          "#306",
          "#306",
          "#306",
          "#306",
          "#000",
        ],
        [
          "#000",
          "#306",
          "#306",
          "#306",
          "#204",
          "#204",
          "#204",
          "#306",
          "#306",
          "#204",
          "#204",
          "#204",
          "#306",
          "#306",
          "#306",
          "#000",
        ],
        [
          "#000",
          "#204",
          "#306",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#306",
          "#204",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
      ],
      attacking: [
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#000",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#519",
          "#519",
          "#111",
          "#111",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#519",
          "#111",
          "#111",
          "#519",
          "#519",
          "#000",
        ],
        [
          "#000",
          "#519",
          "#111",
          "#FF0",
          "#FF0",
          "#111",
          "#519",
          "#519",
          "#519",
          "#519",
          "#111",
          "#FF0",
          "#FF0",
          "#111",
          "#519",
          "#000",
        ],
        [
          "#000",
          "#519",
          "#111",
          "#FFF",
          "#FFF",
          "#111",
          "#519",
          "#519",
          "#519",
          "#519",
          "#111",
          "#FFF",
          "#FFF",
          "#111",
          "#519",
          "#000",
        ],
        [
          "#000",
          "#519",
          "#519",
          "#333",
          "#333",
          "#519",
          "#519",
          "#000",
          "#000",
          "#519",
          "#519",
          "#333",
          "#333",
          "#519",
          "#519",
          "#000",
        ],
        [
          "#000",
          "#519",
          "#519",
          "#000",
          "#000",
          "#000",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#000",
          "#000",
          "#000",
          "#519",
          "#519",
          "#000",
        ],
        [
          "#000",
          "#519",
          "#519",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#FFF",
          "#519",
          "#519",
          "#000",
        ],
        [
          "#000",
          "#519",
          "#519",
          "#306",
          "#306",
          "#519",
          "#306",
          "#306",
          "#306",
          "#306",
          "#519",
          "#306",
          "#306",
          "#519",
          "#519",
          "#000",
        ],
        [
          "#000",
          "#519",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#306",
          "#519",
          "#000",
        ],
        [
          "#000",
          "#306",
          "#306",
          "#306",
          "#306",
          "#204",
          "#306",
          "#306",
          "#306",
          "#306",
          "#204",
          "#306",
          "#306",
          "#306",
          "#306",
          "#000",
        ],
        [
          "#000",
          "#306",
          "#306",
          "#306",
          "#204",
          "#204",
          "#204",
          "#306",
          "#306",
          "#204",
          "#204",
          "#204",
          "#306",
          "#306",
          "#306",
          "#000",
        ],
        [
          "#000",
          "#204",
          "#306",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#306",
          "#204",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#204",
          "#000",
          "#000",
        ],
        [
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
          "#000",
        ],
      ],
    },
  };

  // Death sprite (flat on ground)
  // private readonly DEATH_TEXTURE = [
  //   ['#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000'],
  //   ['#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000'],
  //   ['#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000'],
  //   ['#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000'],
  //   ['#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000'],
  //   ['#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000', '#000'],
  //   ['#000', '#000', '#654', '#654', '#654', '#654', '#654', '#654', '#654', '#654', '#654', '#654', '#654', '#654', '#000', '#000'],
  //   ['#000', '#654', '#654', '#321', '#321', '#654', '#654', '#654', '#654', '#654', '#654', '#321', '#321', '#654', '#654', '#000'],
  //   ['#654', '#654', '#321', '#321', '#321', '#321', '#654', '#654', '#654', '#654', '#321', '#321', '#321', '#321', '#654', '#654'],
  //   ['#654', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#654'],
  //   ['#654', '#321', '#F00', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#321', '#F00', '#321', '#654'],
  //   ['#654', '#654', '#321', '#F00', '#F00', '#321', '#321', '#321', '#321', '#321', '#321', '#F00', '#F00', '#321', '#654', '#654'],
  //   ['#000', '#654', '#654', '#321', '#F00', '#F00', '#F00', '#321', '#321', '#F00', '#F00', '#F00', '#321', '#654', '#654', '#000'],
  //   ['#000', '#000', '#654', '#654', '#321', '#F00', '#F00', '#F00', '#F00', '#F00', '#F00', '#321', '#654', '#654', '#000', '#000'],
  //   ['#000', '#000', '#000', '#654', '#654', '#321', '#321', '#F00', '#F00', '#321', '#321', '#654', '#654', '#000', '#000', '#000'],
  //   ['#000', '#000', '#000', '#000', '#000', '#654', '#654', '#654', '#654', '#654', '#654', '#000', '#000', '#000', '#000', '#000']
  // ];

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      throw new Error("Could not get 2D context from canvas");
    }
    this.ctx = ctx;

    // Initialize canvas dimensions from actual canvas
    this.canvasWidth = canvas.width;
    this.canvasHeight = canvas.height;

    // Scale the number of rays with canvas width for consistent detail
    this.numRays = Math.max(400, Math.floor(this.canvasWidth / 2));

    // Create offscreen canvas for pre-rendering
    this.offscreenCanvas = document.createElement("canvas");
    this.offscreenCanvas.width = this.canvasWidth;
    this.offscreenCanvas.height = this.canvasHeight;
    const offscreenCtx = this.offscreenCanvas.getContext("2d");
    if (!offscreenCtx) {
      throw new Error("Could not get 2D context from offscreen canvas");
    }
    this.offscreenCtx = offscreenCtx;
  }

  public castRay(
    startX: number,
    startY: number,
    angle: number,
    worldMap: number[][]
  ): RayHit {
    const rayDirX = Math.cos(angle);
    const rayDirY = Math.sin(angle);

    let mapX = Math.floor(startX);
    let mapY = Math.floor(startY);

    const deltaDistX = Math.abs(1 / rayDirX);
    const deltaDistY = Math.abs(1 / rayDirY);

    let stepX: number;
    let stepY: number;
    let sideDistX: number;
    let sideDistY: number;

    if (rayDirX < 0) {
      stepX = -1;
      sideDistX = (startX - mapX) * deltaDistX;
    } else {
      stepX = 1;
      sideDistX = (mapX + 1.0 - startX) * deltaDistX;
    }

    if (rayDirY < 0) {
      stepY = -1;
      sideDistY = (startY - mapY) * deltaDistY;
    } else {
      stepY = 1;
      sideDistY = (mapY + 1.0 - startY) * deltaDistY;
    }

    let hit = 0;
    let side = 0;

    while (hit === 0) {
      if (sideDistX < sideDistY) {
        sideDistX += deltaDistX;
        mapX += stepX;
        side = 0;
      } else {
        sideDistY += deltaDistY;
        mapY += stepY;
        side = 1;
      }

      if (worldMap[mapY] && worldMap[mapY][mapX] > 0) {
        hit = 1;
      }
    }

    let perpWallDist: number;
    if (side === 0) {
      perpWallDist = (mapX - startX + (1 - stepX) / 2) / rayDirX;
    } else {
      perpWallDist = (mapY - startY + (1 - stepY) / 2) / rayDirY;
    }

    return {
      distance: perpWallDist,
      side,
      wallType: worldMap[mapY][mapX],
      x: mapX,
      y: mapY,
    };
  }

  private getWallColor(wallType: number, side: number): string {
    // Enhanced wall color themes with vibrant, less muddy colors
    const colorThemes: Record<number, string> = {
      // Base/Border walls
      0: "#000000", // Black - empty space
      1: "#2C3E50", // Dark slate - border walls

      // Tech Base Theme (Blues and Grays)
      2: "#3498DB", // Bright blue - primary tech walls
      3: "#5DADE2", // Light blue - secondary tech walls
      4: "#85C1E9", // Pale blue - accent tech walls
      5: "#7F8C8D", // Cool gray - tech structural

      // Industrial Theme (Metals and Steel)
      6: "#95A5A6", // Light steel
      7: "#BDC3C7", // Bright steel
      8: "#D5DBDB", // Chrome/silver
      9: "#566573", // Dark steel

      // Energy Theme (Greens and Teals)
      10: "#27AE60", // Emerald green
      11: "#58D68D", // Light green
      12: "#82E0AA", // Pale green
      13: "#17A2B8", // Teal

      // Warning Theme (Oranges and Yellows)
      14: "#F39C12", // Orange
      15: "#F7DC6F", // Yellow
      16: "#F8C471", // Light orange
      17: "#E67E22", // Dark orange

      // Danger Theme (Reds and Purples)
      18: "#E74C3C", // Red
      19: "#F1948A", // Light red
      20: "#8E44AD", // Purple
      21: "#A569BD", // Light purple

      // Alien Theme (Exotic colors)
      22: "#AF7AC5", // Lavender
      23: "#85929E", // Blue gray
      24: "#48C9B0", // Turquoise
      25: "#F4D03F", // Bright yellow
    };

    let color = colorThemes[wallType] || "#34495E"; // Default dark blue-gray

    // Apply depth shading to one side
    if (side === 1) {
      // Convert hex to RGB, darken by 30%, convert back
      const hex = color.replace("#", "");
      const r = Math.max(
        0,
        Math.floor(parseInt(hex.substring(0, 2), 16) * 0.7)
      );
      const g = Math.max(
        0,
        Math.floor(parseInt(hex.substring(2, 4), 16) * 0.7)
      );
      const b = Math.max(
        0,
        Math.floor(parseInt(hex.substring(4, 6), 16) * 0.7)
      );
      return `rgb(${r}, ${g}, ${b})`;
    }

    return color;
  }

  // Helper function to draw a scaled, pixelated sprite
  private drawPixelatedSprite(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    width: number,
    height: number,
    texture: string[][]
  ): void {
    if (!texture || texture.length === 0) return;

    const pixelSizeX = width / texture[0].length;
    const pixelSizeY = height / texture.length;

    // Disable image smoothing for crisp pixel art
    ctx.imageSmoothingEnabled = false;

    for (let row = 0; row < texture.length; row++) {
      for (let col = 0; col < texture[0].length; col++) {
        const color = texture[row][col];
        if (color !== "#000") {
          // Treat #000 as transparent
          ctx.fillStyle = color;
          ctx.fillRect(
            x + col * pixelSizeX,
            y + row * pixelSizeY,
            Math.ceil(pixelSizeX),
            Math.ceil(pixelSizeY)
          );
        }
      }
    }
  }

  /**
   * Enhanced texture state application system
   * @author @darianrosebrook
   */
  private applyStateAndHealthToTexture(
    texture: string[][],
    enemy: { state: string; health: number; maxHealth: number },
    isHurt: boolean = false
  ): string[][] {
    if (!texture || texture.length === 0) return texture;

    const newTexture = texture.map((row) => [...row]); // Create a deep copy
    const healthPercentage = enemy.health / enemy.maxHealth;

    // Priority 1: Apply hurt flash (most visible effect)
    if (isHurt) {
      return this.applyHurtFlashEffect(newTexture);
    }

    // Priority 2: Apply health-based visual changes
    if (healthPercentage < 1.0) {
      return this.applyHealthBasedEffects(
        newTexture,
        healthPercentage,
        enemy.state
      );
    }

    return newTexture;
  }

  /**
   * Apply dramatic hurt flash effect for immediate damage feedback
   */
  private applyHurtFlashEffect(texture: string[][]): string[][] {
    const flashTexture = texture.map((row) => [...row]);

    for (let row = 0; row < flashTexture.length; row++) {
      for (let col = 0; col < flashTexture[row].length; col++) {
        const color = flashTexture[row][col];

        if (color !== "#000") {
          // Don't flash transparent pixels
          // Create a bright, very visible flash effect
          const rgb = this.hexToRgb?.(color);
          if (rgb) {
            // Brighten and add red tint for damage indication
            const flashR = Math.min(255, rgb.r + 100);
            const flashG = Math.min(255, Math.floor(rgb.g * 0.8) + 50);
            const flashB = Math.min(255, Math.floor(rgb.b * 0.8) + 50);

            const hexResult = this.rgbToHex?.(flashR, flashG, flashB);
            flashTexture[row][col] = hexResult || "#FFF";
          } else {
            // Fallback: bright red-white flash
            flashTexture[row][col] = "#FFF";
          }
        }
      }
    }

    return flashTexture;
  }

  /**
   * Apply progressive health-based visual effects
   */
  private applyHealthBasedEffects(
    texture: string[][],
    healthPercentage: number,
    state: string
  ): string[][] {
    const healthTexture = texture.map((row) => [...row]);

    // Determine effect intensity based on health
    let darkenFactor = 0;
    let redTint = 0;
    let desaturation = 0;

    if (healthPercentage < 0.1) {
      // Critical health: Very dark, high red tint, desaturated
      darkenFactor = 0.6;
      redTint = 0.4;
      desaturation = 0.8;
    } else if (healthPercentage < 0.25) {
      // Low health: Dark, medium red tint, some desaturation
      darkenFactor = 0.4;
      redTint = 0.3;
      desaturation = 0.5;
    } else if (healthPercentage < 0.5) {
      // Medium health: Slightly dark, light red tint
      darkenFactor = 0.2;
      redTint = 0.15;
      desaturation = 0.2;
    } else if (healthPercentage < 0.75) {
      // High health: Very slight darkening
      darkenFactor = 0.1;
      redTint = 0.05;
      desaturation = 0;
    }

    // Apply attacking state boost
    if (state === "attacking") {
      redTint += 0.1; // Extra red tint when attacking
    }

    // Apply effects to each pixel
    for (let row = 0; row < healthTexture.length; row++) {
      for (let col = 0; col < healthTexture[row].length; col++) {
        const color = healthTexture[row][col];

        if (color !== "#000") {
          // Don't modify transparent pixels
          const modifiedColor =
            this.applyColorEffects?.(
              color,
              darkenFactor,
              redTint,
              desaturation
            ) || color;
          healthTexture[row][col] = modifiedColor;
        }
      }
    }

    return healthTexture;
  }

  /**
   * Enhanced color manipulation utilities
   * @author @darianrosebrook
   */

  /**
   * Convert hex color to RGB object
   */
  private hexToRgb(hex: string): { r: number; g: number; b: number } | null {
    // Remove # prefix if present
    hex = hex.replace("#", "");

    // Handle 3-digit hex codes
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }

    // Validate hex format
    if (hex.length !== 6) {
      return null;
    }

    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);

    // Validate RGB values
    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      return null;
    }

    return { r, g, b };
  }

  /**
   * Convert RGB values to hex color
   */
  private rgbToHex(r: number, g: number, b: number): string {
    // Clamp values to 0-255 range
    r = Math.max(0, Math.min(255, Math.round(r)));
    g = Math.max(0, Math.min(255, Math.round(g)));
    b = Math.max(0, Math.min(255, Math.round(b)));

    return `#${r.toString(16).padStart(2, "0")}${g
      .toString(16)
      .padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
  }

  /**
   * Apply multiple color effects to a hex color
   */
  private applyColorEffects(
    hexColor: string,
    darkenFactor: number,
    redTint: number,
    desaturation: number
  ): string {
    const rgb = this.hexToRgb(hexColor);
    if (!rgb) {
      return hexColor; // Return original if conversion fails
    }

    let { r, g, b } = rgb;

    // Apply darkening
    if (darkenFactor > 0) {
      const multiplier = 1 - darkenFactor;
      r *= multiplier;
      g *= multiplier;
      b *= multiplier;
    }

    // Apply red tint
    if (redTint > 0) {
      r = Math.min(255, r + (255 - r) * redTint);
    }

    // Apply desaturation (convert to grayscale)
    if (desaturation > 0) {
      const gray = r * 0.299 + g * 0.587 + b * 0.114;
      r = r * (1 - desaturation) + gray * desaturation;
      g = g * (1 - desaturation) + gray * desaturation;
      b = b * (1 - desaturation) + gray * desaturation;
    }

    return this.rgbToHex(r, g, b);
  }

  /**
   * Simple hex color darkening (legacy compatibility)
   */
  private darkenHexColor(hex: string, factor: number): string {
    return this.applyColorEffects?.(hex, factor, 0, 0) || hex;
  }

  private drawFirstPersonWeapon(
    ctx: CanvasRenderingContext2D,
    weapon: string,
    isAttacking: boolean,
    muzzleFlash: boolean,
    currentTime: number
  ): void {
    // First-person weapon positioning (bottom center of screen)
    const weaponBaseX = this.canvasWidth / 2;
    const weaponBaseY = this.canvasHeight - 80;

    // Weapon sway and bob effects
    const time = currentTime * 0.001;
    const swayX = Math.sin(time * 2) * 3;
    const swayY = Math.cos(time * 1.5) * 2;

    // Recoil effect when attacking
    const recoilOffset = isAttacking ? 8 : 0; // Simplified without attackTimer
    const recoilX = isAttacking ? (Math.random() - 0.5) * recoilOffset : 0;
    const recoilY = isAttacking ? -recoilOffset : 0;

    const finalX = weaponBaseX + swayX + recoilX;
    const finalY = weaponBaseY + swayY + recoilY;

    // Draw weapon and hands based on type
    switch (weapon) {
      case "pistol":
        this.drawFirstPersonPistol(
          ctx,
          finalX,
          finalY,
          isAttacking,
          muzzleFlash
        );
        break;
      case "shotgun":
        this.drawFirstPersonShotgun(
          ctx,
          finalX,
          finalY,
          isAttacking,
          muzzleFlash
        );
        break;
      case "chaingun":
        this.drawFirstPersonChaingun(
          ctx,
          finalX,
          finalY,
          isAttacking,
          muzzleFlash,
          time
        );
        break;
    }
  }

  private drawFirstPersonPistol(
    ctx: CanvasRenderingContext2D,
    centerX: number,
    centerY: number,
    isAttacking: boolean,
    muzzleFlash: boolean
  ): void {
    ctx.save();

    // Scale for first-person view
    const scale = 3;
    ctx.scale(scale, scale);
    const x = centerX / scale;
    const y = centerY / scale;

    // Draw right hand holding pistol grip
    this.drawHand(ctx, x - 15, y - 5, "right", "pistol");

    // Draw left hand supporting (optional for pistol)
    this.drawHand(ctx, x - 25, y - 8, "left", "pistol");

    // Draw pistol body
    ctx.fillStyle = "#4A4A4A";
    ctx.fillRect(x - 20, y - 20, 25, 12);

    // Pistol barrel
    ctx.fillStyle = "#333333";
    ctx.fillRect(x - 35, y - 18, 15, 8);

    // Pistol grip
    ctx.fillStyle = "#5A5A5A";
    ctx.fillRect(x - 22, y - 8, 8, 15);

    // Trigger guard
    ctx.strokeStyle = "#333333";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(x - 18, y - 3, 4, 0, Math.PI);
    ctx.stroke();

    // Pistol details
    ctx.fillStyle = "#666666";
    ctx.fillRect(x - 18, y - 19, 15, 2); // Top rail
    ctx.fillRect(x - 20, y - 12, 3, 8); // Side detail

    // Muzzle flash
    if (muzzleFlash) {
      this.drawFirstPersonMuzzleFlash(ctx, x - 35, y - 14, 1.0);
    }

    // Ejecting shell casing when firing
    if (isAttacking) {
      // Simplified condition without attackTimer
      this.drawEjectingShell(ctx, x - 10, y - 15);
    }

    ctx.restore();
  }

  private drawFirstPersonShotgun(
    ctx: CanvasRenderingContext2D,
    centerX: number,
    centerY: number,
    isAttacking: boolean,
    muzzleFlash: boolean
  ): void {
    ctx.save();

    // Scale for first-person view
    const scale = 2.5;
    ctx.scale(scale, scale);
    const x = centerX / scale;
    const y = centerY / scale;

    // Draw right hand on grip
    this.drawHand(ctx, x - 10, y, "right", "shotgun");

    // Draw left hand on pump
    this.drawHand(ctx, x - 25, y - 5, "left", "shotgun");

    // Shotgun stock
    ctx.fillStyle = "#6B4423";
    ctx.fillRect(x + 10, y - 5, 20, 10);

    // Shotgun body
    ctx.fillStyle = "#4A4A4A";
    ctx.fillRect(x - 15, y - 8, 35, 14);

    // Shotgun barrel
    ctx.fillStyle = "#333333";
    ctx.fillRect(x - 40, y - 6, 25, 10);

    // Pump action (animated when attacking)
    const pumpOffset = isAttacking ? -3 : 0; // Simplified without attackTimer
    ctx.fillStyle = "#5A5A5A";
    ctx.fillRect(x - 25 + pumpOffset, y - 5, 12, 8);

    // Shotgun details
    ctx.fillStyle = "#666666";
    ctx.fillRect(x - 35, y - 7, 20, 2); // Top rail
    ctx.fillRect(x - 12, y - 9, 25, 2); // Body rail

    // Muzzle flash (larger for shotgun)
    if (muzzleFlash) {
      this.drawFirstPersonMuzzleFlash(ctx, x - 40, y - 1, 1.5);
    }

    // Ejecting shells when firing
    if (isAttacking) {
      // Simplified condition without attackTimer
      this.drawEjectingShell(ctx, x - 5, y - 8);
      this.drawEjectingShell(ctx, x - 3, y - 10);
    }

    ctx.restore();
  }

  private drawFirstPersonChaingun(
    ctx: CanvasRenderingContext2D,
    centerX: number,
    centerY: number,
    isAttacking: boolean,
    muzzleFlash: boolean,
    time: number
  ): void {
    ctx.save();

    // Scale for first-person view
    const scale = 2;
    ctx.scale(scale, scale);
    const x = centerX / scale;
    const y = centerY / scale;

    // Draw both hands gripping the chaingun
    this.drawHand(ctx, x - 8, y + 5, "right", "chaingun");
    this.drawHand(ctx, x - 30, y - 2, "left", "chaingun");

    // Chaingun body
    ctx.fillStyle = "#5A5A5A";
    ctx.fillRect(x - 20, y - 10, 40, 20);

    // Multiple rotating barrels
    const barrelRotation = isAttacking ? time * 20 : 0;
    ctx.save();
    ctx.translate(x - 35, y);
    ctx.rotate(barrelRotation);

    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      const barrelX = Math.cos(angle) * 8;
      const barrelY = Math.sin(angle) * 8;

      ctx.fillStyle = "#4A4A4A";
      ctx.fillRect(barrelX - 2, barrelY - 2, 20, 4);
    }
    ctx.restore();

    // Ammo belt
    ctx.fillStyle = "#FFD700";
    for (let i = 0; i < 8; i++) {
      ctx.fillRect(x + 15 + i * 3, y + 8, 2, 6);
    }

    // Chaingun details
    ctx.fillStyle = "#666666";
    ctx.fillRect(x - 18, y - 12, 35, 3); // Top rail
    ctx.fillRect(x - 15, y + 10, 30, 3); // Bottom rail

    // Ammo feed mechanism
    ctx.fillStyle = "#777777";
    ctx.fillRect(x + 10, y - 5, 8, 15);

    // Muzzle flash (rapid fire)
    if (muzzleFlash) {
      this.drawFirstPersonMuzzleFlash(ctx, x - 35, y, 1.3);
    }

    // Continuous shell ejection when firing
    if (isAttacking) {
      for (let i = 0; i < 3; i++) {
        this.drawEjectingShell(ctx, x - 5 + i * 2, y - 8 + i * 2);
      }
    }

    ctx.restore();
  }

  private drawHand(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    hand: "left" | "right",
    weapon: string
  ): void {
    // Hand color
    ctx.fillStyle = "#D4A574"; // Skin tone

    // Draw palm
    const palmWidth = hand === "right" ? 8 : 7;
    const palmHeight = 12;
    ctx.fillRect(x, y, palmWidth, palmHeight);

    // Draw thumb
    if (hand === "right") {
      ctx.fillRect(x - 2, y + 3, 3, 6);
    } else {
      ctx.fillRect(x + palmWidth, y + 2, 3, 5);
    }

    // Draw fingers based on weapon grip
    switch (weapon) {
      case "pistol":
        this.drawPistolGrip(ctx, x, y, hand);
        break;
      case "shotgun":
        this.drawShotgunGrip(ctx, x, y, hand);
        break;
      case "chaingun":
        this.drawChainguGrip(ctx, x, y, hand);
        break;
    }

    // Add hand details
    ctx.strokeStyle = "#C19A6B";
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, palmWidth, palmHeight);

    // Knuckle lines
    ctx.beginPath();
    ctx.moveTo(x + 2, y + 4);
    ctx.lineTo(x + palmWidth - 2, y + 4);
    ctx.moveTo(x + 2, y + 7);
    ctx.lineTo(x + palmWidth - 2, y + 7);
    ctx.stroke();
  }

  private drawPistolGrip(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    hand: "left" | "right"
  ): void {
    if (hand === "right") {
      // Fingers wrapped around grip
      ctx.fillStyle = "#D4A574";
      ctx.fillRect(x + 6, y + 2, 2, 8); // Index finger
      ctx.fillRect(x + 6, y + 5, 2, 6); // Middle finger
      ctx.fillRect(x + 6, y + 8, 2, 5); // Ring finger
      ctx.fillRect(x + 6, y + 10, 2, 4); // Pinky
    } else {
      // Supporting hand
      ctx.fillRect(x - 2, y + 2, 2, 6); // Fingers
      ctx.fillRect(x - 2, y + 4, 2, 5);
      ctx.fillRect(x - 2, y + 6, 2, 4);
    }
  }

  private drawShotgunGrip(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    hand: "left" | "right"
  ): void {
    if (hand === "right") {
      // Right hand on grip
      ctx.fillStyle = "#D4A574";
      ctx.fillRect(x + 5, y + 2, 3, 8);
      ctx.fillRect(x + 5, y + 5, 3, 6);
      ctx.fillRect(x + 5, y + 8, 3, 5);
    } else {
      // Left hand on pump
      ctx.fillRect(x - 3, y + 1, 4, 7);
      ctx.fillRect(x - 3, y + 3, 4, 6);
      ctx.fillRect(x - 3, y + 5, 4, 5);
    }
  }

  private drawChainguGrip(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    hand: "left" | "right"
  ): void {
    // Both hands gripping firmly
    ctx.fillStyle = "#D4A574";
    if (hand === "right") {
      ctx.fillRect(x + 4, y + 1, 3, 9);
      ctx.fillRect(x + 4, y + 4, 3, 7);
      ctx.fillRect(x + 4, y + 7, 3, 6);
    } else {
      ctx.fillRect(x - 3, y + 1, 4, 8);
      ctx.fillRect(x - 3, y + 3, 4, 7);
      ctx.fillRect(x - 3, y + 5, 4, 6);
    }
  }

  private drawFirstPersonMuzzleFlash(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    scale: number
  ): void {
    ctx.save();
    ctx.translate(x, y);

    // Create animated muzzle flash
    const time = Date.now() * 0.02;
    const flashSize = 12 * scale;

    // Outer flash with jagged edges
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, flashSize);
    gradient.addColorStop(0, "rgba(255, 255, 150, 0.95)");
    gradient.addColorStop(0.3, "rgba(255, 220, 0, 0.8)");
    gradient.addColorStop(0.6, "rgba(255, 100, 0, 0.6)");
    gradient.addColorStop(1, "rgba(255, 0, 0, 0)");

    ctx.fillStyle = gradient;
    ctx.beginPath();

    // Create star-shaped muzzle flash
    const spikes = 12;
    for (let i = 0; i < spikes; i++) {
      const angle = (i / spikes) * Math.PI * 2;
      const isLong = i % 2 === 0;
      const radius =
        flashSize * (isLong ? 1 : 0.5) * (0.8 + Math.sin(time + i) * 0.2);
      const px = Math.cos(angle) * radius;
      const py = Math.sin(angle) * radius;

      if (i === 0) {
        ctx.moveTo(px, py);
      } else {
        ctx.lineTo(px, py);
      }
    }
    ctx.closePath();
    ctx.fill();

    // Inner bright core
    ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
    ctx.beginPath();
    ctx.arc(0, 0, flashSize * 0.3, 0, 2 * Math.PI);
    ctx.fill();

    // Add some sparks
    for (let i = 0; i < 6; i++) {
      const sparkAngle = Math.random() * Math.PI * 2;
      const sparkDistance = flashSize * (0.8 + Math.random() * 0.4);
      const sparkX = Math.cos(sparkAngle) * sparkDistance;
      const sparkY = Math.sin(sparkAngle) * sparkDistance;

      ctx.fillStyle = `rgba(255, ${150 + Math.random() * 105}, 0, ${
        0.6 + Math.random() * 0.4
      })`;
      ctx.beginPath();
      ctx.arc(sparkX, sparkY, 1 + Math.random() * 2, 0, 2 * Math.PI);
      ctx.fill();
    }

    ctx.restore();
  }

  private drawEjectingShell(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number
  ): void {
    // Draw shell casing being ejected
    ctx.save();

    const rotation = Math.random() * Math.PI;
    ctx.translate(x, y);
    ctx.rotate(rotation);

    // Shell casing
    ctx.fillStyle = "#B8860B"; // Brass color
    ctx.fillRect(-2, -1, 4, 2);

    // Shell cap
    ctx.fillStyle = "#DAA520";
    ctx.fillRect(-2, -1, 1, 2);

    ctx.restore();
  }

  private drawPickupSprite(
    ctx: CanvasRenderingContext2D,
    centerX: number,
    centerY: number,
    width: number,
    height: number,
    pickup: {
      type: string;
      value: number;
      spawnTime: number;
      animationOffset: number;
      weaponType?: string;
    },
    currentTime: number
  ): void {
    // Animation calculations
    const animationTime = (currentTime - pickup.spawnTime) * 0.001; // Convert to seconds
    const bobOffset = Math.sin(animationTime * 4 + pickup.animationOffset) * 5; // Vertical bobbing
    const rotationOffset = animationTime * 2 + pickup.animationOffset; // Rotation animation
    const pulseScale =
      1 + Math.sin(animationTime * 6 + pickup.animationOffset) * 0.1; // Pulsing effect

    // Apply animations
    const animatedCenterY = centerY + bobOffset;
    const animatedWidth = width * pulseScale;
    const animatedHeight = height * pulseScale;

    // Draw glow effect
    let glowColor;
    switch (pickup.type) {
      case "health":
        glowColor = "rgba(255, 0, 0, 0.3)";
        break;
      case "weapon":
        glowColor = "rgba(255, 255, 0, 0.3)";
        break;
      default:
        glowColor = "rgba(0, 100, 255, 0.3)";
    }

    ctx.fillStyle = glowColor;
    ctx.beginPath();
    ctx.ellipse(
      centerX,
      animatedCenterY,
      animatedWidth * 0.8,
      animatedHeight * 0.4,
      0,
      0,
      2 * Math.PI
    );
    ctx.fill();

    // Main pickup body
    if (pickup.type === "health") {
      this.drawHealthPickup(
        ctx,
        centerX,
        animatedCenterY,
        animatedWidth,
        animatedHeight,
        rotationOffset
      );
    } else if (pickup.type === "weapon") {
      this.drawWeaponPickup(
        ctx,
        centerX,
        animatedCenterY,
        animatedWidth,
        animatedHeight,
        rotationOffset,
        pickup.weaponType || "shotgun"
      );
    } else {
      this.drawAmmoPickup(
        ctx,
        centerX,
        animatedCenterY,
        animatedWidth,
        animatedHeight,
        rotationOffset
      );
    }

    // Draw pickup value indicator
    if (animatedWidth > 20) {
      // Only for larger sprites
      ctx.fillStyle = "#FFFFFF";
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 2;
      ctx.font = `${Math.max(8, animatedWidth / 6)}px monospace`;
      ctx.textAlign = "center";
      const text =
        pickup.type === "weapon"
          ? pickup.weaponType?.toUpperCase() || "WEAPON"
          : `+${pickup.value}`;

      // Draw text with stroke for visibility
      ctx.strokeText(text, centerX, animatedCenterY - animatedHeight / 2 - 10);
      ctx.fillText(text, centerX, animatedCenterY - animatedHeight / 2 - 10);
    }
  }

  private drawHealthPickup(
    ctx: CanvasRenderingContext2D,
    centerX: number,
    centerY: number,
    width: number,
    height: number,
    rotation: number
  ): void {
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(rotation);

    // Health pack base (dark red background)
    ctx.fillStyle = "#8B0000";
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = Math.max(1, width / 20);
    ctx.fillRect(-width / 2, -height / 2, width, height);
    ctx.strokeRect(-width / 2, -height / 2, width, height);

    // Red cross symbol
    ctx.fillStyle = "#FF0000";
    const crossWidth = width * 0.6;
    const crossHeight = height * 0.6;
    const crossThickness = Math.max(3, width / 8);

    // Horizontal bar of cross
    ctx.fillRect(
      -crossWidth / 2,
      -crossThickness / 2,
      crossWidth,
      crossThickness
    );

    // Vertical bar of cross
    ctx.fillRect(
      -crossThickness / 2,
      -crossHeight / 2,
      crossThickness,
      crossHeight
    );

    // Highlight effect
    ctx.fillStyle = "#FF6666";
    ctx.fillRect(
      -crossWidth / 2,
      -crossThickness / 2,
      crossWidth,
      crossThickness / 2
    );
    ctx.fillRect(
      -crossThickness / 2,
      -crossHeight / 2,
      crossThickness / 2,
      crossHeight
    );

    ctx.restore();
  }

  private drawWeaponPickup(
    ctx: CanvasRenderingContext2D,
    centerX: number,
    centerY: number,
    width: number,
    height: number,
    rotation: number,
    weaponType: string
  ): void {
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(rotation);

    // Weapon case base
    ctx.fillStyle = "#4A4A4A";
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = Math.max(1, width / 20);
    ctx.fillRect(-width / 2, -height / 2, width, height);
    ctx.strokeRect(-width / 2, -height / 2, width, height);

    // Weapon-specific icon
    ctx.fillStyle = "#FFD700";
    const iconSize = Math.min(width, height) * 0.6;

    if (weaponType === "shotgun") {
      // Shotgun barrel
      ctx.fillRect(-iconSize / 2, -iconSize / 6, iconSize * 0.8, iconSize / 3);
      // Stock
      ctx.fillRect(-iconSize / 2, 0, iconSize / 3, iconSize / 4);
    } else if (weaponType === "chaingun") {
      // Multiple barrels
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(
          -iconSize / 2,
          -iconSize / 3 + (i * iconSize) / 6,
          iconSize * 0.7,
          iconSize / 8
        );
      }
    }

    // Highlight effect
    ctx.fillStyle = "#FFFF99";
    ctx.fillRect(-width / 2, -height / 2, width, height / 3);

    ctx.restore();
  }

  private drawAmmoPickup(
    ctx: CanvasRenderingContext2D,
    centerX: number,
    centerY: number,
    width: number,
    height: number,
    rotation: number
  ): void {
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(rotation);

    // Ammo box base (dark blue/gray background)
    ctx.fillStyle = "#2F4F4F";
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = Math.max(1, width / 20);
    ctx.fillRect(-width / 2, -height / 2, width, height);
    ctx.strokeRect(-width / 2, -height / 2, width, height);

    // Ammo box details
    ctx.fillStyle = "#4682B4";
    const boxWidth = width * 0.8;
    const boxHeight = height * 0.8;
    ctx.fillRect(-boxWidth / 2, -boxHeight / 2, boxWidth, boxHeight);

    // Ammo bullets/shells pattern
    ctx.fillStyle = "#FFD700"; // Gold color for bullets
    const bulletSize = Math.max(2, width / 12);
    const spacing = bulletSize * 2;

    for (let i = -1; i <= 1; i++) {
      for (let j = -1; j <= 1; j++) {
        ctx.beginPath();
        ctx.ellipse(
          i * spacing,
          j * spacing,
          bulletSize,
          bulletSize,
          0,
          0,
          2 * Math.PI
        );
        ctx.fill();

        // Bullet tip highlight
        ctx.fillStyle = "#FFFF99";
        ctx.beginPath();
        ctx.ellipse(
          i * spacing,
          j * spacing - bulletSize / 2,
          bulletSize / 2,
          bulletSize / 2,
          0,
          0,
          2 * Math.PI
        );
        ctx.fill();
        ctx.fillStyle = "#FFD700";
      }
    }

    // Box highlight
    ctx.fillStyle = "#87CEEB";
    ctx.fillRect(-boxWidth / 2, -boxHeight / 2, boxWidth, boxHeight / 3);

    ctx.restore();
  }

  private drawEnemySprite(
    ctx: CanvasRenderingContext2D,
    centerX: number,
    centerY: number,
    width: number,
    height: number,
    enemy: {
      x: number;
      y: number;
      state: string;
      health: number;
      maxHealth: number;
      enemyType: string;
    },
    // playerX: number,
    // playerY: number,
    isHurt: boolean = false
  ): void {
    // Size variation based on enemy type
    const sizeMultiplier =
      enemy.enemyType === "captain"
        ? 1.2
        : enemy.enemyType === "soldier"
        ? 1.1
        : 1.0;
    const adjustedWidth = width * sizeMultiplier;
    const adjustedHeight = height * sizeMultiplier;

    // Draw shadow for depth
    ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
    ctx.fillRect(
      centerX - adjustedWidth / 2 + 2,
      centerY + adjustedHeight / 2 - 6,
      adjustedWidth,
      6
    );

    // Determine which texture to use based on enemy type and state
    let baseTexture: string[][];
    const textures =
      this.ENEMY_TEXTURES[enemy.enemyType as keyof typeof this.ENEMY_TEXTURES];

    if (textures) {
      if (enemy.state === "attacking" && textures.attacking) {
        baseTexture = textures.attacking;
      } else {
        baseTexture = textures.idle;
      }
    } else {
      // Fallback to grunt texture
      baseTexture = this.ENEMY_TEXTURES.grunt.idle;
    }

    // Apply state and health modifications to texture
    const finalTexture = this.applyStateAndHealthToTexture(
      baseTexture,
      enemy,
      isHurt
    );

    // Draw the pixelated sprite
    const drawX = centerX - adjustedWidth / 2;
    const drawY = centerY - adjustedHeight / 2;
    this.drawPixelatedSprite(
      ctx,
      drawX,
      drawY,
      adjustedWidth,
      adjustedHeight,
      finalTexture
    );

    // Draw health bar for damaged enemies
    const healthPercentage = enemy.health / enemy.maxHealth;
    if (healthPercentage < 1.0 && adjustedWidth > 15) {
      const barWidth = adjustedWidth * 0.8;
      const barHeight = 3;
      const barY = centerY - adjustedHeight / 2 - 8;

      // Background
      ctx.fillStyle = "#000000";
      ctx.fillRect(centerX - barWidth / 2, barY, barWidth, barHeight);

      // Health bar
      const healthColor =
        healthPercentage > 0.6
          ? "#00FF00"
          : healthPercentage > 0.3
          ? "#FFFF00"
          : "#FF0000";
      ctx.fillStyle = healthColor;
      ctx.fillRect(
        centerX - barWidth / 2,
        barY,
        barWidth * healthPercentage,
        barHeight
      );
    }

    // Draw enemy type indicator (only for larger sprites)
    if (adjustedWidth > 20) {
      const indicatorY = centerY - adjustedHeight / 2 - 20;
      let indicatorText = "";
      let indicatorColor = "#FFFFFF";

      switch (enemy.enemyType) {
        case "grunt":
          indicatorText = "G";
          indicatorColor = "#FFFF00";
          break;
        case "soldier":
          indicatorText = "S";
          indicatorColor = "#00FF00";
          break;
        case "captain":
          indicatorText = "C";
          indicatorColor = "#FF00FF";
          break;
      }

      ctx.fillStyle = indicatorColor;
      ctx.font = `${Math.max(8, adjustedWidth / 5)}px monospace`;
      ctx.textAlign = "center";
      ctx.fillText(indicatorText, centerX, indicatorY);

      // State indicator below type
      const stateY = indicatorY + 12;
      switch (enemy.state) {
        case "attacking":
          ctx.fillStyle = "#FF0000";
          ctx.fillText("!", centerX, stateY);
          break;
        case "chasing":
          ctx.fillStyle = "#FFA500";
          ctx.fillText("?", centerX, stateY);
          break;
        case "patrolling":
          ctx.fillStyle = "#FFFF00";
          ctx.fillText("~", centerX, stateY);
          break;
      }
    }
  }

  // private darkenColor(color: string, factor: number): string {
  //   // Simple color darkening function
  //   const hex = color.replace('#', '');
  //   const r = Math.max(0, Math.min(255, parseInt(hex.substring(0, 2), 16) * (1 - factor)));
  //   const g = Math.max(0, Math.min(255, parseInt(hex.substring(2, 4), 16) * (1 - factor)));
  //   const b = Math.max(0, Math.min(255, parseInt(hex.substring(4, 6), 16) * (1 - factor)));
  //
  //   return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
  // }

  public render(
    playerX: number,
    playerY: number,
    playerAngle: number,
    enemies: Array<{
      x: number;
      y: number;
      state: string;
      health: number;
      maxHealth: number;
      enemyType: string;
      isHurt: boolean;
    }>,
    pickups: Array<{
      x: number;
      y: number;
      type: string;
      value: number;
      spawnTime: number;
      animationOffset: number;
      weaponType?: string;
    }>,
    worldMap: number[][],
    currentTime: number,
    playerWeapon?: string,
    isAttacking?: boolean,
    muzzleFlash?: boolean,
    // attackTimer?: number,
    weaponRange?: number
  ): void {
    // Use offscreen canvas for double buffering
    const ctx = this.offscreenCtx;

    // Clear screen with background gradient for performance
    ctx.fillStyle = "#2F2F2F";
    ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);

    // Pre-render ceiling and floor
    ctx.fillStyle = "#1F1F1F";
    ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight / 2);

    ctx.fillStyle = "#3F3F3F";
    ctx.fillRect(
      0,
      this.canvasHeight / 2,
      this.canvasWidth,
      this.canvasHeight / 2
    );

    // Batch raycasting for walls
    this.renderWalls(ctx, playerX, playerY, playerAngle, worldMap);

    // Render all sprites (enemies and pickups) with z-buffer consideration
    this.renderSprites(
      ctx,
      playerX,
      playerY,
      playerAngle,
      enemies,
      pickups,
      worldMap,
      currentTime
    );

    // Render first-person weapon and hands
    if (playerWeapon) {
      this.drawFirstPersonWeapon(
        ctx,
        playerWeapon,
        isAttacking || false,
        muzzleFlash || false,
        currentTime
      );
    }

    // Render crosshair with range feedback
    this.renderCrosshair(
      ctx,
      enemies,
      playerX,
      playerY,
      playerAngle,
      weaponRange
    );

    // Copy offscreen canvas to main canvas (double buffering)
    this.ctx.drawImage(this.offscreenCanvas, 0, 0);
  }

  private renderWalls(
    ctx: CanvasRenderingContext2D,
    playerX: number,
    playerY: number,
    playerAngle: number,
    worldMap: number[][]
  ): void {
    const stripWidth = this.canvasWidth / this.numRays;

    for (let x = 0; x < this.numRays; x++) {
      const cameraX = (2 * x) / this.numRays - 1;
      const rayAngle =
        playerAngle + Math.atan(cameraX * Math.tan(this.FOV / 2));

      const hit = this.castRay(playerX, playerY, rayAngle, worldMap);

      const lineHeight = this.canvasHeight / hit.distance;
      const drawStart = Math.max(0, -lineHeight / 2 + this.canvasHeight / 2);
      const drawEnd = Math.min(
        this.canvasHeight,
        lineHeight / 2 + this.canvasHeight / 2
      );

      ctx.fillStyle = this.getWallColor(hit.wallType, hit.side);
      ctx.fillRect(
        x * stripWidth,
        drawStart,
        stripWidth + 1,
        drawEnd - drawStart
      );
    }
  }

  private renderSprites(
    ctx: CanvasRenderingContext2D,
    playerX: number,
    playerY: number,
    playerAngle: number,
    enemies: Array<{
      x: number;
      y: number;
      state: string;
      health: number;
      maxHealth: number;
      enemyType: string;
      isHurt: boolean;
    }>,
    pickups: Array<{
      x: number;
      y: number;
      type: string;
      value: number;
      spawnTime: number;
      animationOffset: number;
      weaponType?: string;
    }>,
    worldMap: number[][],
    currentTime: number
  ): void {
    // Combine all sprites and sort by distance for proper z-ordering
    const allSprites: Array<{
      x: number;
      y: number;
      distance: number;
      type: "enemy" | "pickup";
      data: any;
    }> = [];

    // Add enemies to sprite list
    enemies.forEach((enemy) => {
      const distance = Math.sqrt(
        (enemy.x - playerX) ** 2 + (enemy.y - playerY) ** 2
      );
      allSprites.push({
        x: enemy.x,
        y: enemy.y,
        distance,
        type: "enemy",
        data: enemy,
      });
    });

    // Add pickups to sprite list
    pickups.forEach((pickup) => {
      const distance = Math.sqrt(
        (pickup.x - playerX) ** 2 + (pickup.y - playerY) ** 2
      );
      allSprites.push({
        x: pickup.x,
        y: pickup.y,
        distance,
        type: "pickup",
        data: pickup,
      });
    });

    // Sort by distance (farthest first for proper depth rendering)
    allSprites.sort((a, b) => b.distance - a.distance);

    // Render all sprites
    allSprites.forEach((sprite) => {
      const spriteAngle = Math.atan2(sprite.y - playerY, sprite.x - playerX);
      const angleFromPlayer = spriteAngle - playerAngle;

      // Normalize angle
      let normalizedAngle = angleFromPlayer;
      while (normalizedAngle > Math.PI) normalizedAngle -= 2 * Math.PI;
      while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;

      if (Math.abs(normalizedAngle) < this.FOV / 2) {
        const screenX =
          (normalizedAngle / (this.FOV / 2)) * (this.canvasWidth / 2) +
          this.canvasWidth / 2;
        let spriteHeight = this.canvasHeight / sprite.distance;
        let spriteWidth = spriteHeight * 0.8; // Default width ratio

        // Adjust size for pickups (make them smaller)
        if (sprite.type === "pickup") {
          spriteWidth *= 0.6;
          spriteHeight *= 0.6;
        }

        // Check if sprite is visible (not behind wall)
        const hit = this.castRay(playerX, playerY, spriteAngle, worldMap);
        if (hit.distance > sprite.distance) {
          if (sprite.type === "enemy") {
            this.drawEnemySprite(
              ctx,
              screenX,
              this.canvasHeight / 2,
              spriteWidth,
              spriteHeight,
              sprite.data,
              sprite.data.isHurt
            );
          } else if (sprite.type === "pickup") {
            this.drawPickupSprite(
              ctx,
              screenX,
              this.canvasHeight / 2,
              spriteWidth,
              spriteHeight,
              sprite.data,
              currentTime
            );
          }
        }
      }
    });
  }

  private renderCrosshair(
    ctx: CanvasRenderingContext2D,
    enemies?: Array<{
      x: number;
      y: number;
      state: string;
      health: number;
      maxHealth: number;
      enemyType: string;
    }>,
    playerX?: number,
    playerY?: number,
    playerAngle?: number,
    weaponRange?: number
  ): void {
    // Default crosshair color
    let crosshairColor = "#FFFFFF";

    // Check if player is aiming at an enemy within range
    if (
      enemies &&
      playerX !== undefined &&
      playerY !== undefined &&
      playerAngle !== undefined &&
      weaponRange !== undefined
    ) {
      const accuracyTolerance = 0.3; // Generous aiming tolerance for visual feedback

      for (const enemy of enemies) {
        const enemyDistance = Math.sqrt(
          (enemy.x - playerX) ** 2 + (enemy.y - playerY) ** 2
        );

        // Check if enemy is in aiming direction
        const enemyAngle = Math.atan2(enemy.y - playerY, enemy.x - playerX);
        let angleDiff = Math.abs(playerAngle - enemyAngle);
        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;

        if (angleDiff < accuracyTolerance) {
          if (enemyDistance <= weaponRange) {
            crosshairColor = "#00FF00"; // Green - enemy in range
          } else {
            crosshairColor = "#FF6600"; // Orange - enemy out of range
          }
          break;
        }
      }
    }

    ctx.strokeStyle = crosshairColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.canvasWidth / 2 - 10, this.canvasHeight / 2);
    ctx.lineTo(this.canvasWidth / 2 + 10, this.canvasHeight / 2);
    ctx.moveTo(this.canvasWidth / 2, this.canvasHeight / 2 - 10);
    ctx.lineTo(this.canvasWidth / 2, this.canvasHeight / 2 + 10);
    ctx.stroke();
  }

  public resize(width: number, height: number): void {
    this.canvas.width = width;
    this.canvas.height = height;
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.offscreenCanvas.width = width;
    this.offscreenCanvas.height = height;

    // Scale the number of rays with canvas width for consistent detail
    this.numRays = Math.max(400, Math.floor(width / 2));
  }
}
